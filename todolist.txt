get_next_line_bonus

Output
・結果を出力する関数。

☑️・Retが0以下の場合エラー

☑️・EOFの場合return 0

☑️・それ以外の場合、appendline関数で1を返し、読み込んだ行を静的変数の現在のアドレスに保存する。


Append_line
☑️・行の長さを計り、一行をline変数に追加。

☑️・インデックスlenで文字が改行されている場合、見つかった長さまでの文字列をlineに保存。

☑️・行を追加するから、現在のアドレスを更新するため、保存データを開放。

☑️・*sを解放して、残りのデータを一時的に格納した文字列と等しくする。

☑️・改行の後の残りのデータを一時的に保存するものを作成。

☑️・lineがNULL文字の場合

☑️・ファイルの最後の時点で、不要になるメモリ*sを解放。


get_next_line
☑️・whileは読み込まれたバイト数が存在するかで回す

☑️・EOFまで読み込む

☑️・Static変数を使用し、get_next_lineが呼ばれる時は、前回呼ばれた物を記憶しておく。静的変数を使用。

☑️(ft_strdup)・最初に呼び出された時、静的変数の**sが空なのかを確認する。もし、空だった場合、バッファでメモリーをmallocする。

☑️(ft_strjoin)・ループの最中では、ラインを読み込み、一時的に記憶させている文を使用し、結合する。

☑️・ループは改行の時に、外れるようにする、

☑️・Output関数で何を返すか確認

☑️・ファイルディスクリプたから新しい文を読み込み、改行文字で終わる行を返す。

☑️・メモリを解放せずにループで読み込むとリークを起こす。

☑️・一時的に記憶させるものは、繰り返しのたびに保存されてるデータを上書きして、どれだけ読み込んだかわかるように、前の保存データを削除できるようにする。
↑
これは、BUFF_SIZEで決定されたnバイトしか読み込まないために必要。




実装イメージ
例). 
	text = "aaaaa\nbbb\ncccccccccc\ndddd"
	BUFFER_SIZE = 4
	buf = readしたものを格納
	save = staticで、端文字列を保存する
	line = 出力する文字列

１回目の呼び出し
・read1周目
	buf = "aaaa"//　BUFFER_SIZE=4文字入る
	save = ""
	line = ""

・read2週目
	buf = "a\nbb"//5-8文字目が入る
	save = "aaaa" //前bufを預かる
	line = "aaaaa"//改行が現れたので、それまでのsave + bufの改行前の文字列を作成

	save = "bb" //buf内の改行以降の文字列を保存
	<出力結果>
		"aaaaa"

２回目の呼び出し
	buf = "b\ncc" //9-13文字目が読まれる
	save = "bb" //前回の端数文字列
	line = "bbb" //改行文字が現れたので、save + bufを作成

	save = "cc" //buf = "b\ncc"なので、改行以降の文字を保存
	<出力結果>
		"bbb"